@import "../SassFP";


@function range-list( $first, $last ) {
  $output: ();
  @for $i from $first through $last {
    $output: append($output, $i);
  }
  @return $output;
}


// Begin data-col fns


@function single-column-calc( $num-cols, $gutter ) {
  @return ( 100 - ( $gutter * ( $num-cols - 1 ) ) ) / $num-cols;
}

@function column-width-calc( $span, $num-cols, $gutter ) {
  $single-column: single-column-calc( $num-cols, $gutter );
  @return $single-column + ( ( $single-column + $gutter ) * ( $span - 1 ) );
}

@function single-col-px($gutter-width, $total-width, $total-span) {
  @return ( $total-width - ( ( $total-span - 1 ) * $gutter-width ) ) / $total-span;
};

@function span-width-calc( $gutter-width, $total-width, $total-span, $span ) {
  $single-col: single-col-px( $gutter-width, $total-width, $total-span );
  $col-margin-ratio: $single-col / $gutter-width;
  @return ( $span * ( $gutter-width * $col-margin-ratio ) ) + ( ( $span - 1 ) * $gutter-width );
}

@function offset-width-calc( $gutter-width, $total-width, $total-span, $span ) {
  $single-col: single-col-px( $gutter-width, $total-width, $total-span );
  $col-margin-ratio: $single-col / $gutter-width;
  @return ( $span * ( $gutter-width * $col-margin-ratio ) ) + ( $span * $gutter-width );
}

@function create-width-map( $curr-gutter, $curr-width, $num-cols, $span, $depth ) {
  $px-span: span-width-calc( $curr-gutter, $curr-width, $num-cols, $span );
  $px-offset: offset-width-calc( $curr-gutter, $curr-width, $num-cols, $span );
  $lookup-span: inspect( $span );
  $nested-data: ();

  @if $span > 1 and $span <= $num_cols and $depth < 1 {
    $nested-data: map-merge(
      $nested-data,
      reduce(
        (create-width-data, $curr-gutter, $px-span, $span, inc( $depth )),
        (),
        range-list(1, dec( $span ))
      )
    );
  }
  @else {
    $nested-data: null;
  }

  @return (
    span: (
      px: $px-span,
      pct: percent( $px-span, $curr-width )
    ),
    offset: (
      px: $px-offset,
      pct: percent( $px-offset, $curr-width )
    ),
    nests: $nested-data
  );
}

@function create-width-data( $curr-gutter, $curr-width, $num-cols, $depth, $data-map, $span ) {
  @return map-merge(
    $data-map,
    ( $span: create-width-map( $curr-gutter, $curr-width, $num-cols, $span, $depth ) )
  );
}

@function create-column-data( $num-cols, $data-map, $width-data ) {
  $width-id: prop( 'id', $width-data );
  $curr-width: prop( 'max', $width-data );
  $curr-gutter: prop( 'gutter', $width-data );
  $curr-gutter-size: percent( $curr-gutter, $curr-width );
  $col-list: range-list( 1, $num-cols );

  @return map-merge(
    $data-map,
    (
      #{$curr-width}: (
        id: $width-id,
        gutter: $curr-gutter,
        max: $curr-width,
        widths: reduce(
          (create-width-data, $curr-gutter, $curr-width, $num-cols, 0),
          (),
          $col-list
        )
      )
    )
  );
}

@function create-columns-data( $seed ) {
  @return reduce(
    (create-column-data, prop( 'cols', $seed ) ),
    (),
    prop( 'widths', $seed )
  );
}

@function kebab-class( $list ) {
  @return compose(
    (prefixStr, '.'),
    (implode, '-'),
    $list
  );
}

// Data
$column-data: (
  cols: 12,
  names: (
    gen: 'col',
    offset: 'offset',
    order: 'ord',
  ),
  widths: (
    (
      id: 'xs',
      cols: 8,
      max: 480,
      gutter: 8,
    ),
    (
      id: 'sm',
      cols: 12,
      max: 768,
      gutter: 12,
    ),
    (
      id: 'md',
      cols: 12,
      max: 992,
      gutter: 12,
    ),
    (
      id: 'lg',
      cols: 12,
      max: 1200,
      gutter: 14,
    ),
  ),
  first-mq: 768,
);

// Mixins
@mixin col-media-query( $width, $first-mq ) {
  @if $width >= $first-mq {
    @media only screen and (min-width: #{$width + 1}px) {
      @content;
    }
  }
  @else {
    @content;
  }
}


// output CSS
body {
  margin: 0;
  padding: 0;
  font-family: monospace;
  line-height: 1.2
}

.bgo {
  background-color: orange;
}

.bgs {
  background-color: silver;
}

.rspnsv-image img {
  max-width: 100%;
}

.row {
  box-sizing: border-box;
  display: flex;
  flex-flow: row wrap;
  justify-content: space-between;
  & > * {
    box-sizing: border-box;
    border: 1px solid #000;
  }
}

// Assemble the data
$all-data: map-merge(
  $column-data,
  (specs: create-columns-data( $column-data ))
);

@mixin generate-columns( $col-data ) {
  // Create some convenience variables
  $gen-name: path( ( 'names', 'gen' ), $col-data );
  $order-name: path( ( 'names', 'order' ), $col-data );
  $offset-name: path( ( 'names', 'offset' ), $col-data );
  $first-id: prop( 'id', head( prop( 'widths', $col-data ) ) );

  $acc-selectors: ();

  // Accumulate full width classes here
  // above all the others to use the cascade
  $full-width-classes: ();
  %full-width-class {
    width: 100%;
  }

  // Iterate over the data to create the rest of the output.
  // The @each iterator in use here allows looping over a
  // hash map, but doesn't support index lookups during the
  // loop, so a current index is kept track of by way of a
  // mutating variable, $idx. That index is needed late to
  // limit which nested selectors are going to get output
  $idx: 0;
  @each $width, $width-data in prop( 'specs', $col-data) {
    $id: prop( 'id', $width-data );
    $idx: inc($idx);
    $max: prop( 'max', $width-data );
    $overrides: ();
    $bp-spans: ();
    $bp-offsets: ();
    @each $bp-name in prop( 'widths', $col-data ) {
      $bp-spans: map-merge(
        $bp-spans,
        (prop( 'id', $bp-name ): ()),
      );
      $bp-offsets: map-merge(
        $bp-offsets,
        (prop( 'id', $bp-name ): ()),
      );
    }

    @include col-media-query(
      $max,
      prop( 'first-mq', $col-data )
    ) {
      @each $span, $span-data in prop( 'widths', $width-data ) {
        $base-selector: kebab-class( ( $gen-name, $id, $span ) );
        $offset-selector: kebab-class( ( $gen-name, $id, $offset-name, $span ) );
        $order-selector: kebab-class( ( $order-name, $id, $span ) );
        $curr-width: path( ( 'widths', $span, 'span', 'pct' ), $width-data );
        $curr-offset: path( ( 'widths', $span, 'offset', 'pct' ), $width-data );
        $curr-nests: path( ( 'widths', $span, 'nests' ), $width-data );
        $prev-bases: path( ( $span, 'bases' ), $acc-selectors);
        $prev-offsets: path( ( $span, 'offsets' ), $acc-selectors);
        $nest-parent: if(
          isnt_null( $prev-bases ),
          append( $prev-bases, $base-selector ),
          $base-selector
        );

        // All but the first size needs to be full-width by default
        // Add the rest to the full-width list
        @if $id != $first-id {
          $full-width-classes: append( $full-width-classes, $base-selector, comma );
        }

        // Width classes
        // Don't bother outputting the last column since it will
        // always be full-width, and a full-width offset also
        // doesn't make sense. Instead, attach them to the full-width list.
        // Use this area to output any previously iterated-over classnames
        // so they can be avaiable, but overridden using the cascade below
        @if $span !=  prop( 'cols', $col-data) {
          // Create the nested selectors
          @if isnt_null( $curr-nests ) {
            @each $nested-span, $nested-data in $curr-nests {
              $nested-classes: ();
              // Limit to those that are the current media query sizes
              // and smaller to allow larger sized selectors to remain
              // at full width until their media query gets hit
              @each $seed-span-data in slice( 1, $idx, prop( 'widths', $col-data ) ) {
                $nested-classes: append(
                  $nested-classes,
                  kebab-class(
                    (
                      $gen-name,
                      prop( 'id', $seed-span-data ),
                      $nested-span
                    )
                  ),
                  comma
                );
              }

              // Relies on Sass' ability to take multiple parents
              // with multiple children to create all the combinations
              // as a comma-separated list of selectors
              #{ $nest-parent } {
                #{ $nested-classes } {
                  width: path( ('span', 'pct' ), $nested-data );
                }
              }
            }
          }

          // Add the current width and offset to the overrides list
          // This list needs to be accumulated during this loop
          // but ouput later to ensure a lower spot in the cascade
          $overrides: append( $overrides, (
            class: ( $base-selector, $curr-width ),
            offset: ( $offset-selector, $curr-offset ),
          ) );

          // Same goes for the previous classes that have already
          // been added. They will need to be grouped with their
          // breakpoint-named siblings to ensure that smaller sizes
          // can have the appropriately resized sizes in larger
          // breakpoints. In other words, when gutters change sizes
          // in different breakpoints, it is not necessary for a user
          // to explicitly add every size to every element, but only
          // the smallest size at which they wish to see the layout.
          // eg, `col-xs-4` will be 4 spans wide thru `sm`, 'md', and `lg`
          // and it won't need to be restated for each of those
          @if isnt_null( $prev-bases ) {
            // Add to $bp-spans
            @each $selector in $prev-bases {
              @if isnt_null( $selector ) {
                $bp-name: nth( explode( '-', $selector ), 2 );
                $bp-list: prop( $bp-name, $bp-spans );
                $bp-list: append(
                  $bp-list,
                  ($selector, $curr-width),
                );
                $bp-spans: map-merge(
                  $bp-spans,
                  ($bp-name: $bp-list),
                );
              }
            }
          }

          // Repeat for offsets (see above comment)
          @if isnt_null( $prev-offsets ) {
            // Add to $bp-offsets
            @each $selector in $prev-offsets {
              @if isnt_null( $selector ) {
                $bp-name: nth( explode( '-', $selector ), 2 );
                $bp-list: prop( $bp-name, $bp-offsets );
                $bp-list: append(
                  $bp-list,
                  ($selector, $curr-offset),
                );
                $bp-offsets: map-merge(
                  $bp-offsets,
                  ($bp-name: $bp-list),
                );
              }
            }
          }

          // Smaller columns need to be updated with the values generated
          // by their larger cousins. Hold on to previous class names
          // to include them in later iterations
          $acc-selectors: map-merge(
            $acc-selectors,
            (
              $span: (
                bases: append( path( ( $span, 'bases' ), $acc-selectors ), $base-selector, comma ),
                offsets: append( path( ( $span, 'offsets' ), $acc-selectors ), $offset-selector, comma ),
              )
            )
          );
        }
        // this is for the smallest size classes
        // to follow a mobile-first strategy
        // as well as all the classes whose
        // span is the same as the max as an optimization
        @else {
          $full-width-classes: append( $full-width-classes, $base-selector, comma );
        }

        // Order classes
        #{ $order-selector } {
          order: $span;
        }
      }

      // Each id will need a special offset-0 class
      #{kebab-class( ( $gen-name, $id, $offset-name, 0 ) )} {
        margin-left: 0;
      }

      // Output previously (ie, smaller breakpoints) defined width selectors
      // They will be grouped according to breakpoint size first,
      // then column width, allowing larger breakpoint sizes to
      // cascade over previously defined widths. In other words,
      // `xs` sizes get redefined so they can adjust to larger
      // breakpoints' changing gutter sizes. They need to be grouped
      // with the others of their same breakpoints to ensure that
      // larger breakpoints with smaller column widths can override
      // smaller breakpoints' definitions with larger widths
      @each $bp-name, $override in $bp-spans {
        // Previously sized columns
        @each $classinfo in $override {
          #{head( $classinfo )} {
            width: #{last( $classinfo )};
          }
        }
      }

      // Repeat for offsets
      @each $bp-name, $override in $bp-offsets {
        // Previously sized offsets
        @each $classinfo in $override {
          #{head( $classinfo )} {
            margin-left: #{last( $classinfo )};
          }
        }
      }

      // Output the standalone, new column-sizing classes
      // and offsets here to ensure that they get priority
      @each $override in $overrides {
        #{ head( prop( 'class', $override ) ) } {
          width:  last( prop( 'class', $override ) );
        }
        #{ head( prop( 'offset', $override ) ) } {
          margin-left:  last( prop( 'offset', $override ) );
        }
      }
    }
  }

  // All iterations have been completed.
  // Output the list of full-width classes
  // above everything else to ensure they
  // can be overridden by the cascade
  #{ $full-width-classes } {
    @extend %full-width-class;
  }
}

@include generate-columns( $all-data );
